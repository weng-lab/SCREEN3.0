"use client";

import React, { useEffect, useMemo, useState } from "react";
import { DNAAlphabet, DNALogo } from "logo-test";
import { useQuery } from "@apollo/client";
import {
  DataTable,
  DataTableColumn,
  GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD,
  GridColDef,
  gridFilteredDescendantCountLookupSelector,
  GridGroupingColDefOverride,
  isAutogeneratedRow,
  Table,
  useGridApiRef,
} from "@weng-lab/ui-components";
import { gql } from "common/types/generated";
import { LinkComponent } from "common/components/LinkComponent";
import { EntityViewComponentProps } from "common/entityTabsConfig";
import { useCcreData } from "common/hooks/useCcreData";
import { GenomicRange } from "common/types/globalTypes";
import { Stack, Tabs, Tab } from "@mui/material";
import { useCcreRpeaks } from "common/hooks/useCcreRpeaks";

type TFBindData = {
  name: string;
  n: number;
  total: number;
};

export const CRE_TF_DCC_QUERY = gql(`
  query tfpeaks_1($assembly: String, $range: [ChromosomeRangeInput]!, $target: String) {
    peaks(assembly: $assembly, range: $range, target: $target) {
      peaks {
        chrom
        chrom_start
        chrom_end
        dataset {
          biosample
          accession
          target
          files(types: "replicated_peaks") {
            accession
          }
        }
      }
    }
  }
`);

export const TF_INTERSECTION_QUERY = gql(`
  query tfpeaks_2($assembly: String, $range: [ChromosomeRangeInput]!, $species: String) {
    peaks(assembly: $assembly, range: $range) {
      peaks {
        chrom
        chrom_start
        chrom_end
        dataset {
          biosample
          accession
          target
        }
      }
    }
    peakDataset(species: $species) {
      partitionByTarget {
        target {
          name
        }
        counts {
          total
        }
      }
    }
  }
`);

const TF_BINDING_QUERY = gql(`
  query tf_binding_query(
    $assembly: String
    $range: [ChromosomeRangeInput]!
  ) {
    peaks(assembly: $assembly, range: $range) {
      peaks {
        dataset {
          target
          biosample
        }
        experiment_accession
        file_accession
      }
    }
  }
`);

const TF_EXPERIMENT_TOTALS = gql(`
  query tf_exp_totals(
  $species: String
    ) {
    peakDataset(species: $species) {
      partitionByTarget {
        target {
          name
        }
        counts {
          total
        }
      }
    }
  }
`);

//partitionByTarget gives us the total number of experiments targeting that TF
//The second query is only giving us the replicated peaks accession
//How much slower is it to do all in one?

export const TfBinding = ({ entity }: EntityViewComponentProps) => {
 const [tab, setTab] = useState<"binding_tfs" | "overlapping_peaks">("overlapping_peaks") ;
 const [dataMap, setDataMap] = useState<Map<string, number[][]>>(new Map());
  
  useEffect(() => {
    fetch("/green-motifs.json") // Replace with actual filename in public folder
      .then((res) => res.json())
      .then((json) => {
        const tfMap = new Map<string, number[][]>();

        Object.keys(json).forEach((entry) => {
          tfMap.set(entry, json[entry].trimmed_ppm);
        });

        setDataMap(tfMap);
      })
      .catch((err) => {
        console.error("Error loading JSON:", err);
      });
  }, []);

  const assembly = entity.assembly;
 

  const handleChange = (event: React.SyntheticEvent, newValue: string) => {
    setTab(newValue as "binding_tfs" | "overlapping_peaks");
  };

  const {
    data: dataCcreRPeaks,
    loading: loadingCcreRPeaks,
    error: errorCcreRPeaks,
  } = useCcreRpeaks({
    assembly: entity.assembly,
    accession: [entity.entityID],
  });
  const {
    data: dataCcre,
    loading: loadingCcre,
    error: errorCcre,
  } = useCcreData({
    assembly: entity.assembly,
    accession: entity.entityID,
  });

  const coordinates: GenomicRange = dataCcre
    ? { chromosome: dataCcre.chrom, start: dataCcre.start, end: dataCcre.start + dataCcre.len }
    : null;

  const {
    loading: loadingTfBinding,
    data: tfBindingData,
    error: errorTfBindingData,
  } = useQuery(TF_BINDING_QUERY, {
    variables: {
      assembly: assembly.toLowerCase(),
      range: {
        chrom: coordinates?.chromosome,
        chrom_start: coordinates?.start,
        chrom_end: coordinates?.end,
      },
    },
    skip: !coordinates,
    fetchPolicy: "cache-and-network",
    nextFetchPolicy: "cache-first",
  });

  const {
    loading: loadingTfTotals,
    data: tfTotalsData,
    error: errorTfTotals,
  } = useQuery(TF_EXPERIMENT_TOTALS, {
    variables: {
      species: assembly === "GRCh38" ? "Homo sapiens" : "Mus musculus",
    },
    fetchPolicy: "cache-and-network",
    nextFetchPolicy: "cache-first",
  });

  const tfTotals: Record<string, number> = useMemo(() => {
    if (!tfTotalsData || errorTfTotals) return null;
    const entries = {};
    tfTotalsData.peakDataset.partitionByTarget.forEach((x) => {
      entries[x.target.name] = x.counts.total; //Creates an entry for the tf with it's total number of experiments
    });
    return entries;
  }, [tfTotalsData, errorTfTotals]);

  // This doesn't work since the reference to the total function is stale

  //Create the rows. Deduplicate entries which have the same experiment accession and the same coordinates.
  const rows = useMemo(
    () =>
      tfBindingData
        ? Array.from(
          new Map(
            tfBindingData.peaks.peaks.map((x) => {
              const obj = {
                tf: x.dataset.target,
                biosample: x.dataset.biosample,
                expID: x.experiment_accession,
                fileID: x.file_accession,
              };
              return [`${obj.expID}}`, obj]; // Use expID as unique ID to deduplicate
            })
          ).values()
        )
        : undefined,
    [tfBindingData]
  );
  const overlappingPeaksCols: GridColDef<any>[] = [
    {
      field: "tf",
      headerName: "Transcription Factor",
       renderCell: (params) => (
        <LinkComponent
          href={`https://www.factorbook.org/tf/human/${params.value}/function`}
          openInNewTab
          showExternalIcon
          underline="hover"
          onClick={(e) => e.stopPropagation()}
        >
          {params.value}
        </LinkComponent>
      ),
    },
    {
      field: "tf_logo",
      sortable: false,
      width: 500,
      filterable: false,      
      headerName: "Motif Logo",
      
      renderCell : (params) => {
        //console.log("params", params.rowNode.type==="group" && params.rowNode.isAutoGenerated &&  params.rowNode.groupingKey===params.row.tf)
        return (
          <>
          {
          //dataMap && params.rowNode.type==="group" && params.rowNode.isAutoGenerated && dataMap.get(params.rowNode.groupingKey as string) ?
          dataMap && dataMap.get(params.row.tf) ?
           <DNALogo
                    //ppm={dataMap.get(params.rowNode.groupingKey as string)}
                    ppm={dataMap.get(params.row.tf)}
                    width={200}
                    height={60}
                  />
           : <></>}
           </>
        )
      }
    },
    
   {
      field: "rpeak_chromosome",
      headerName: "Chromosome"
    },
    {
      headerName: "Start",
      field: "rpeak_start",
      valueFormatter: (value: number) => value?.toLocaleString(),
    },
    {
      headerName: "Stop",
      field: "rpeak_stop",
      valueFormatter: (value: number) => value?.toLocaleString(),
    },
    {
      field: "decorator_chromosome",
      headerName: "Motif Site Chromosome"
    },
    {
      headerName: "Motif Site Start",
      field: "decorator_start",
      valueFormatter: (value: number) => value?.toLocaleString(),
    },
    {
      headerName: "Motif Site Stop",
      field: "decorator_stop",
      valueFormatter: (value: number) => value?.toLocaleString(),
    },
  ];
  const columns: GridColDef<(typeof rows)[number]>[] = [
    {
      field: "tf",
      headerName: "Transcription Factor",
      renderCell: (params) => (
        <LinkComponent
          href={`https://www.factorbook.org/tf/human/${params.value}/function`}
          openInNewTab
          showExternalIcon
          underline="hover"
          onClick={(e) => e.stopPropagation()}
        >
          {params.value}
        </LinkComponent>
      ),
    },
    {
      field: "total",
      headerName: "Total Experiments for TF",
      renderCell: (params) =>
        params.rowNode.type === "group" && params.rowNode.groupingField === "tf" && tfTotals
          ? tfTotals[params.rowNode.groupingKey as string]
          : null,
    },
    {
      field: "biosample",
      headerName: "Biosample",
    },
    {
      field: "expID",
      headerName: "ChIP-Seq Experiment Supporting Binding",
      renderCell: (params) =>
        isAutogeneratedRow(params.row) ? null : (
          <LinkComponent
            href={`https://www.encodeproject.org/experiments/${params.value}/`}
            openInNewTab
            showExternalIcon
            underline="hover"
          >
            {params.value}
          </LinkComponent>
        ),
    },
    {
      field: "fileID",
      headerName: "IDR thresholded peaks",
      renderCell: (params) =>
        isAutogeneratedRow(params.row) ? null : (
          <LinkComponent
            href={`https://www.encodeproject.org/files/${params.value}/`}
            openInNewTab
            showExternalIcon
            underline="hover"
          >
            {params.value}
          </LinkComponent>
        ),
    },
  ];

  const apiRef = useGridApiRef();
  const rPeaks_apiRef = useGridApiRef();

  const groupingColDef: GridGroupingColDefOverride = React.useMemo(
    () => ({
      width: 275,
      sortComparator: (v1, v2, cellParams1, cellParams2) => {
        if (cellParams1.rowNode.type === "group" && cellParams2.rowNode.type === "group") {
          // Sort the values, but only within the same group
          if (cellParams1.rowNode.groupingField === cellParams2.rowNode.groupingField) {
            const filteredDescendantCountLookup = gridFilteredDescendantCountLookupSelector(apiRef);
            const cell1DescendantCount = filteredDescendantCountLookup[cellParams1.rowNode.id] ?? 0;
            const cell2DescendantCount = filteredDescendantCountLookup[cellParams2.rowNode.id] ?? 0;

            const cell1TF =
              cellParams1.rowNode.groupingField === "tf" ? (cellParams1.rowNode.groupingKey as string) : null;

            const cell2TF =
              cellParams2.rowNode.groupingField === "tf" ? (cellParams2.rowNode.groupingKey as string) : null;

            if (cell1DescendantCount === cell2DescendantCount) return cell2TF.localeCompare(cell1TF);

            return cell1DescendantCount - cell2DescendantCount;
          }
          return 0;
        }

        if (cellParams1.rowNode.type === "group") {
          return 1;
        }

        if (cellParams2.rowNode.type === "group") {
          return -1;
        }

        return 0;
      },
    }),
    [apiRef]
  );

  return (
    <>
     <Tabs
        variant="scrollable"
        scrollButtons="auto"
        allowScrollButtonsMobile
        value={tab}
        onChange={handleChange}
        sx={{
          "& .MuiTabs-scrollButtons.Mui-disabled": {
            opacity: 0.3,
          },
        }}
      >
        <Tab value="binding_tfs" label="Overlapping ChIP-seq Peaks" />
        <Tab value="overlapping_peaks" label="Bound Transcription Factors" />
      </Tabs>
      {tab==="binding_tfs" ? <Table
        apiRef={apiRef}
        rows={rows}
        columns={columns}
        loading={loadingTfBinding}
        error={!!errorTfBindingData}
        label={`TFs that bind to ${entity.entityID}`}
        disableRowGrouping={false}
        divHeight={{ height: 600 }}
        groupingColDef={groupingColDef}
        initialState={{
          rowGrouping: {
            model: ["tf"],
          },
          sorting: {
            sortModel: [{ field: GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD, sort: "desc" }],
          },
        }}
      />:
      <Table
        label={`Overlapping Representative ChIP-seq Peaks for transcription factors and other DNA-associated proteins`}
      //  apiRef={apiRef}
        loading={loadingCcreRPeaks}
        error={!!errorCcreRPeaks}
        columns={overlappingPeaksCols}
        rows={dataCcreRPeaks}
        rowHeight={100}
      //  groupingColDef={groupingColDef}
        emptyTableFallback={"No Overlapping Representative ChIP-seq Peaks found"}
        disableRowGrouping={false}
       /* initialState={{
          rowGrouping: {
            model: ["tf"],
          },
          sorting: {
            sortModel: [{ field: GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD, sort: "desc" }],
          },
        }}*/
      />}
    </>
  );
};
